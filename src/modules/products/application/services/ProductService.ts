import { ProductUseCase, ProductCreatePayload, ProductUpdatePayload } from "../domain/ports/in/ProductUseCase";
import { ProductRepository, ProdutoListagemDTO } from "../domain/ports/out/ProductRepository";
import { Product } from "../domain/entities/Product";
import { v4 as uuidv4 } from 'uuid';

export class ProductService implements ProductUseCase {
  constructor(private readonly productRepository: ProductRepository) {}

  async listarProdutos(categoryName?: string): Promise<{ produtos: ProdutoListagemDTO[]; timestamp: string }> {
    const produtos = await this.productRepository.findAll(categoryName);
    return {
        produtos: produtos,
        timestamp: new Date().toISOString()
    };
  }

  // Keep internal getProductById if needed for other use cases
  async getProductById(id: string): Promise<Product | null> {
    return this.productRepository.findById(id);
  }

  // Method to get product details formatted for API response (if different from internal)
  // async getProductDetailsForApi(id: string): Promise<ProdutoDetalheDTO | null> { ... }

  async createProduct(productData: ProductCreatePayload): Promise<Product> {
    // Ensure category exists
    const categoryExists = await this.productRepository.categoryExists(productData.categoryId);
    if (!categoryExists) {
      throw new Error(`Categoria com ID ${productData.categoryId} não encontrada.`);
    }

    const newProduct = new Product(
      null, // ID will be generated by constructor or DB
      productData.name,
      productData.description,
      productData.price,
      productData.imageUrl,
      productData.categoryId,
      productData.stock,
      new Date(),
      new Date(),
      productData.disponivel,
      productData.destaque
    );

    // Validate domain rules (constructor already does some)
    // Additional validations can go here

    return this.productRepository.save(newProduct);
  }

  async updateProduct(id: string, productData: ProductUpdatePayload): Promise<Product | null> {
    const existingProduct = await this.productRepository.findById(id);
    if (!existingProduct) {
      return null; // Product not found
    }

    // Check if category is being updated and if the new one exists
    if (productData.categoryId !== undefined && productData.categoryId !== existingProduct.categoryId) {
        const categoryExists = await this.productRepository.categoryExists(productData.categoryId);
        if (!categoryExists) {
            throw new Error(`Categoria com ID ${productData.categoryId} não encontrada.`);
        }
    }

    // Apply updates using the domain entity's method
    existingProduct.updateDetails(productData);

    // Persist changes
    return this.productRepository.update(existingProduct);
  }

  async deleteProduct(id: string): Promise<boolean> {
    // Check if product exists before attempting delete
    const exists = await this.productRepository.findById(id);
    if (!exists) {
        return false;
    }
    return this.productRepository.delete(id);
  }

  // --- Methods corresponding to legacy routes (adjust or remove) ---

  // Example: Adapt getAllProducts for legacy route if needed
  async getAllProductsLegacy(): Promise<Product[]> { // Returns domain entities
      const productDTOs = await this.productRepository.findAll(); // Assuming findAll returns DTOs
      // Need to fetch full domain entities if legacy route expects them
      // This might require adjustments in the repository or an additional method
      const productIds = productDTOs.map(p => p.id);
      const products = await Promise.all(productIds.map(id => this.productRepository.findById(id)));
      return products.filter(p => p !== null) as Product[];
  }

  // Example: Adapt getProductsByCategory for legacy route
  async getProductsByCategoryLegacy(categoryId: number): Promise<Product[]> { // Returns domain entities
      return this.productRepository.findByCategoryId(categoryId);
  }

}

