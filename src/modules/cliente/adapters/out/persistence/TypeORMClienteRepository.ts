import { Injectable } from '@nestjs/common'; // Assuming NestJS context, adjust if plain Express
import { InjectRepository } from '@nestjs/typeorm'; // Assuming NestJS context
import { Repository } from 'typeorm';
import { Cliente } from '../../domain/entities/Cliente';
import { ClienteRepository } from '../../domain/ports/out/ClienteRepository';
import { ClienteEntity } from './entities/Cliente.entity';
import { v4 as uuidv4 } from 'uuid';

// @Injectable() // Uncomment if using NestJS dependency injection
export class TypeORMClienteRepository implements ClienteRepository {

  // constructor(
  //   @InjectRepository(ClienteEntity)
  //   private readonly clienteRepository: Repository<ClienteEntity>,
  // ) {} 
  // Basic implementation without NestJS DI for now
  constructor(private readonly typeormRepository: Repository<ClienteEntity>) {}

  private mapEntityToDomain(entity: ClienteEntity): Cliente {
    return new Cliente(
      entity.id,
      entity.nome,
      entity.email,
      entity.cpf,
      entity.telefone,
      entity.data_nascimento, // TypeORM handles date conversion
      entity.ultimo_pedido_at
    );
  }

  private mapDomainToEntity(domain: Cliente): Partial<ClienteEntity> {
      // Partial because id might be generated by DB
      return {
          id: domain.id,
          nome: domain.nome,
          email: domain.email,
          cpf: domain.cpf,
          telefone: domain.telefone,
          data_nascimento: domain.dataNascimento,
          // ultimo_pedido_at is likely managed elsewhere or via triggers
      };
  }

  async findByCpf(cpf: string): Promise<Cliente | null> {
    const entity = await this.typeormRepository.findOne({ where: { cpf } });
    return entity ? this.mapEntityToDomain(entity) : null;
  }

  async findByEmail(email: string): Promise<Cliente | null> {
    const entity = await this.typeormRepository.findOne({ where: { email } });
    return entity ? this.mapEntityToDomain(entity) : null;
  }

  async findById(id: string): Promise<Cliente | null> {
    const entity = await this.typeormRepository.findOne({ where: { id } });
    return entity ? this.mapEntityToDomain(entity) : null;
  }

  async save(cliente: Cliente): Promise<Cliente> {
    // Check if client exists to decide between create or update
    let entity = await this.typeormRepository.findOne({ where: { id: cliente.id } });

    if (entity) {
        // Update existing entity
        Object.assign(entity, this.mapDomainToEntity(cliente));
    } else {
        // Create new entity instance
        entity = this.typeormRepository.create(this.mapDomainToEntity(cliente) as ClienteEntity);
        // Ensure ID is set if provided, otherwise let TypeORM handle it (if using auto-generation)
        if (!entity.id) {
            entity.id = uuidv4(); // Assign a new UUID if not provided
        }
    }

    const savedEntity = await this.typeormRepository.save(entity);
    return this.mapEntityToDomain(savedEntity);
  }
}

